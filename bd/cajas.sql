CREATE TABLE APERTURA_CAJA (
    caja_id              NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id              NUMBER NOT NULL, 
    local_id             NUMBER DEFAULT 1,
    
    -- TIEMPOS
    caja_fechainicio     DATE DEFAULT SYSDATE,
    caja_fechafin        DATE, 
    
    -- DINERO ENTRADA/SALIDA
    caja_monto_inicial   NUMBER(10,2) DEFAULT 0, -- Base
    caja_total_ventas    NUMBER(10,2) DEFAULT 0, -- Ingresos por ventas
    caja_total_compras   NUMBER(10,2) DEFAULT 0, -- Egresos por compras (gastos de caja)
    
    -- CUADRE FINAL
    caja_monto_sistema   NUMBER(10,2) DEFAULT 0, -- Lo que debería haber
    caja_monto_real      NUMBER(10,2) DEFAULT 0, -- Lo que contó el cajero
    caja_diferencia      NUMBER(10,2) DEFAULT 0, -- Sobrante o Faltante
    
    -- ESTADO Y OBSERVACIONES
    caja_estado          CHAR(1) DEFAULT '1', -- '1': Abierta, '0': Cerrada
    caja_observacion     VARCHAR2(255),
    
    CONSTRAINT fk_caja_user FOREIGN KEY (user_id) REFERENCES USUARIO(user_id)
);




CREATE OR REPLACE PROCEDURE SP_VERIFICAR_CAJA_ABIERTA (
    p_user_id IN NUMBER,
    p_resultado OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN p_resultado FOR
    SELECT caja_id, caja_fechainicio, caja_monto_inicial
    FROM APERTURA_CAJA
    WHERE user_id = p_user_id 
      AND caja_estado = '1'
    ORDER BY caja_id DESC
    FETCH FIRST 1 ROWS ONLY;
END;
/

CREATE OR REPLACE PROCEDURE SP_ABRIR_CAJA (
    p_user_id       IN NUMBER,
    p_monto_inicial IN NUMBER,
    p_respuesta     OUT VARCHAR2
) AS
    v_existe NUMBER;
BEGIN
    -- 1. Validar si ya tiene caja abierta
    SELECT COUNT(*) INTO v_existe 
    FROM APERTURA_CAJA 
    WHERE user_id = p_user_id AND caja_estado = '1';

    IF v_existe > 0 THEN
        p_respuesta := 'ERROR: Ya tienes una caja abierta.';
    ELSE
        INSERT INTO APERTURA_CAJA (user_id, caja_monto_inicial, caja_estado, caja_fechainicio)
        VALUES (p_user_id, p_monto_inicial, '1', SYSDATE);
        
        COMMIT;
        p_respuesta := 'OK: Caja abierta correctamente.';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        p_respuesta := 'ERROR: ' || SQLERRM;
END;
/


CREATE OR REPLACE PROCEDURE SP_OBTENER_RESUMEN_CAJA (
    p_caja_id IN NUMBER,
    p_cursor  OUT SYS_REFCURSOR
) AS
    v_inicial      NUMBER(10,2) := 0;
    v_ventas       NUMBER(10,2) := 0;
    v_compras      NUMBER(10,2) := 0;
BEGIN
    -- 1. Obtener monto inicial de esta caja específica
    SELECT caja_monto_inicial 
    INTO v_inicial
    FROM APERTURA_CAJA 
    WHERE caja_id = p_caja_id;

    -- 2. Sumar VENTAS vinculadas a este ID de caja (¡Mucho más seguro!)
    SELECT NVL(SUM(venta_total), 0) INTO v_ventas
    FROM VENTA
    WHERE caja_id = p_caja_id; 

    -- 3. Sumar COMPRAS vinculadas a este ID de caja
    SELECT NVL(SUM(compra_montototal), 0) INTO v_compras
    FROM COMPRA
    WHERE caja_id = p_caja_id;

    -- 4. Devolver cálculos
    OPEN p_cursor FOR
    SELECT 
        v_inicial AS monto_inicial,
        v_ventas AS total_ventas,
        v_compras AS total_egresos,
        (v_inicial + v_ventas - v_compras) AS saldo_esperado_sistema
    FROM DUAL;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        -- Si el ID no existe
        OPEN p_cursor FOR 
        SELECT 0 AS monto_inicial, 0 AS total_ventas, 0 AS total_egresos, 0 AS saldo_esperado_sistema FROM DUAL;
END;
/

CREATE OR REPLACE PROCEDURE SP_CERRAR_CAJA (
    p_caja_id        IN NUMBER,
    p_monto_real     IN NUMBER, -- Lo que contó el usuario (billetes en mano)
    p_observacion    IN VARCHAR2,
    p_respuesta      OUT VARCHAR2
) AS
    v_ventas       NUMBER(10,2) := 0;
    v_compras      NUMBER(10,2) := 0;
    v_inicial      NUMBER(10,2) := 0;
    v_sistema      NUMBER(10,2) := 0;
BEGIN
    -- 1. Recuperar monto inicial
    SELECT caja_monto_inicial 
    INTO v_inicial
    FROM APERTURA_CAJA WHERE caja_id = p_caja_id;

    -- 2. Recalcular usando caja_id (Blindado contra errores de fecha)
    SELECT NVL(SUM(venta_total), 0) INTO v_ventas
    FROM VENTA WHERE caja_id = p_caja_id;

    SELECT NVL(SUM(compra_montototal), 0) INTO v_compras
    FROM COMPRA WHERE caja_id = p_caja_id;

    -- 3. Calcular Saldo Sistema
    v_sistema := v_inicial + v_ventas - v_compras;

    -- 4. Actualizar y Cerrar
    UPDATE APERTURA_CAJA SET
        caja_fechafin = SYSDATE,
        caja_total_ventas = v_ventas,
        caja_total_compras = v_compras,
        caja_monto_sistema = v_sistema,
        caja_monto_real = p_monto_real,
        caja_diferencia = p_monto_real - v_sistema, -- Si es negativo, falta dinero
        caja_estado = '0', -- Cerrada
        caja_observacion = p_observacion
    WHERE caja_id = p_caja_id;

    COMMIT;
    p_respuesta := 'OK: Caja cerrada correctamente.';

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        p_respuesta := 'ERROR: ' || SQLERRM;
END;
/

select * from apertura_caja;



-- 1. Vista para facilitar la consulta (opcional pero recomendada)
CREATE OR REPLACE VIEW VW_HISTORIAL_CAJAS AS
SELECT 
    c.caja_id,
    c.user_id,
    u.user_nombres || ' ' || u.user_apellidos as cajero_nombre,
    c.caja_fechainicio,
    c.caja_fechafin,
    c.caja_monto_inicial,
    c.caja_total_ventas,
    c.caja_total_compras,
    c.caja_monto_sistema,
    c.caja_monto_real,
    c.caja_diferencia,
    c.caja_estado, -- '1' Abierta, '0' Cerrada
    c.caja_observacion
FROM APERTURA_CAJA c
JOIN USUARIO u ON c.user_id = u.user_id;

-- 2. Procedimiento de Listado
CREATE OR REPLACE PROCEDURE SP_LISTAR_CAJAS (
    p_cursor OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN p_cursor FOR
    SELECT * FROM VW_HISTORIAL_CAJAS
    ORDER BY caja_id DESC; -- Las más recientes primero
END;
/


select * from VW_HISTORIAL_CAJAS;

-- Agregar la relación en VENTAS
ALTER TABLE VENTA ADD caja_id NUMBER;
ALTER TABLE VENTA ADD CONSTRAINT fk_venta_caja 
    FOREIGN KEY (caja_id) REFERENCES APERTURA_CAJA(caja_id);

-- Agregar la relación en COMPRAS
ALTER TABLE COMPRA ADD caja_id NUMBER;
ALTER TABLE COMPRA ADD CONSTRAINT fk_compra_caja 
    FOREIGN KEY (caja_id) REFERENCES APERTURA_CAJA(caja_id);
    
    
    
    -------------------------------------------------



CREATE OR REPLACE VIEW V_AUDITORIA AS
SELECT 
    a.audi_id,
    a.audi_tabla,
    a.audi_registroid,
    a.audi_operacion,
    a.audi_datoantig,
    a.audi_datonuevo,
    a.user_id,
    u.user_nombres,  
    a.audi_estado,
    a.audi_fechregistro
FROM AUDITORIA a
 LEFT JOIN USUARIO u ON a.user_id = u.user_id;



-- 1. Cabecera del Paquete
CREATE OR REPLACE PACKAGE PKG_AUDITORIA AS
    PROCEDURE SP_LISTAR_AUDITORIA(
        p_page_number  IN NUMBER,      -- Página actual (1, 2, 3...)
        p_page_size    IN NUMBER,      -- Registros por página (ej. 10)
        p_filtro       IN VARCHAR2,    -- Búsqueda por tabla u operación (opcional)
        p_total_recs   OUT NUMBER,     -- Total de registros encontrados (para el front)
        p_cursor       OUT SYS_REFCURSOR -- Los datos
    );
END PKG_AUDITORIA;
/

-- 2. Cuerpo del Paquete
CREATE OR REPLACE PACKAGE BODY PKG_AUDITORIA AS

    PROCEDURE SP_LISTAR_AUDITORIA(
        p_page_number  IN NUMBER,
        p_page_size    IN NUMBER,
        p_filtro       IN VARCHAR2,
        p_total_recs   OUT NUMBER,
        p_cursor       OUT SYS_REFCURSOR
    ) IS
        v_offset NUMBER;
        v_filtro VARCHAR2(100);
    BEGIN
        -- Calcular desde qué fila empezar
        v_offset := (p_page_number - 1) * p_page_size;
        
        -- Normalizar filtro para búsqueda insensible a mayúsculas/minúsculas
        v_filtro := '%' || UPPER(p_filtro) || '%';

        -- 1. Obtener el conteo total (necesario para la paginación en Angular)
        SELECT COUNT(*)
        INTO p_total_recs
        FROM AUDITORIA
        WHERE audi_estado = '1'
          AND (p_filtro IS NULL OR UPPER(audi_tabla) LIKE v_filtro OR UPPER(audi_operacion) LIKE v_filtro);

        -- 2. Obtener los registros paginados
        OPEN p_cursor FOR
            SELECT 
                audi_id,
                audi_tabla,
                audi_registroid,
                audi_operacion,
                audi_datoantig,
                audi_datonuevo,
                user_id,
                audi_fechregistro
            FROM AUDITORIA
            WHERE audi_estado = '1'
              AND (p_filtro IS NULL OR UPPER(audi_tabla) LIKE v_filtro OR UPPER(audi_operacion) LIKE v_filtro)
            ORDER BY audi_id DESC -- Lo más reciente primero
            OFFSET v_offset ROWS FETCH NEXT p_page_size ROWS ONLY;

    END SP_LISTAR_AUDITORIA;

END PKG_AUDITORIA;
/

CREATE OR REPLACE TRIGGER trg_auditoria_cliente
AFTER INSERT OR UPDATE OR DELETE ON CLIENTE
FOR EACH ROW
DECLARE
    v_operacion     VARCHAR2(50);
    v_id_afectado   NUMBER;
    v_antiguo       CLOB;
    v_nuevo         CLOB;
    v_usuario_id    NUMBER; -- 1. Declaramos variable para el usuario
BEGIN

    -- 2. CAPTURAMOS EL USUARIO DE LA SESIÓN
    -- Intentamos leer el identificador. Si es nulo (ej: cambio manual en BD), ponemos 0.
    v_usuario_id := NVL(TO_NUMBER(SYS_CONTEXT('USERENV', 'CLIENT_IDENTIFIER')), 0);

    IF DELETING THEN
        v_operacion := 'ELIMINAR';
        v_id_afectado := :OLD.client_id;

        v_antiguo := TO_CLOB(
            JSON_OBJECT(
                'client_id' VALUE :OLD.client_id,
                'client_cedula' VALUE :OLD.client_cedula,
                'client_nombres' VALUE :OLD.client_nombres,
                'client_apellidos' VALUE :OLD.client_apellidos,
                'client_estado' VALUE :OLD.client_estado
            )
        );

        v_nuevo := NULL;

    ELSIF UPDATING THEN

        v_operacion := 'ACTUALIZAR';
        v_id_afectado := :NEW.client_id;

        v_antiguo := TO_CLOB(
            JSON_OBJECT(
                'client_id' VALUE :OLD.client_id,
                'client_cedula' VALUE :OLD.client_cedula,
                'client_nombres' VALUE :OLD.client_nombres,
                'client_apellidos' VALUE :OLD.client_apellidos,
                'client_estado' VALUE :OLD.client_estado
            )
        );

        v_nuevo := TO_CLOB(
            JSON_OBJECT(
                'client_id' VALUE :NEW.client_id,
                'client_cedula' VALUE :NEW.client_cedula,
                'client_nombres' VALUE :NEW.client_nombres,
                'client_apellidos' VALUE :NEW.client_apellidos,
                'client_estado' VALUE :NEW.client_estado
            )
        );

    ELSIF INSERTING THEN

        v_operacion := 'REGISTRAR';
        v_id_afectado := :NEW.client_id;

        v_antiguo := NULL;

        v_nuevo := TO_CLOB(
            JSON_OBJECT(
                'client_id' VALUE :NEW.client_id,
                'client_cedula' VALUE :NEW.client_cedula,
                'client_nombres' VALUE :NEW.client_nombres,
                'client_apellidos' VALUE :NEW.client_apellidos,
                'client_estado' VALUE :NEW.client_estado
            )
        );

    END IF;

    -- 3. INSERTAMOS EN AUDITORIA INCLUYENDO EL ID DE USUARIO
    INSERT INTO AUDITORIA (
        audi_tabla, 
        audi_registroid, 
        audi_operacion,
        audi_datoantig, 
        audi_datonuevo, 
        audi_fechregistro, 
        audi_estado,
        user_id -- <--- Campo nuevo en la tabla Auditoria
    ) VALUES (
        'CLIENTE', 
        v_id_afectado, 
        v_operacion,
        v_antiguo, 
        v_nuevo, 
        SYSDATE, 
        '1',
        v_usuario_id -- <--- Valor capturado de la sesión
    );

END;
/


CREATE OR REPLACE PACKAGE BODY PKG_AUDITORIA AS

    PROCEDURE SP_LISTAR_AUDITORIA(
        p_page_number  IN NUMBER,
        p_page_size    IN NUMBER,
        p_filtro       IN VARCHAR2,
        p_total_recs   OUT NUMBER,
        p_cursor       OUT SYS_REFCURSOR
    ) IS
        v_offset NUMBER;
        v_filtro VARCHAR2(100);
    BEGIN
        -- Calcular offset para paginación
        v_offset := (p_page_number - 1) * p_page_size;
        
        -- Normalizar filtro (Búsqueda por tabla, operación o nombre de usuario)
        v_filtro := '%' || UPPER(p_filtro) || '%';

        -- 1. Obtener Total (Usando la Vista)
        SELECT COUNT(*)
        INTO p_total_recs
        FROM V_AUDITORIA
        WHERE audi_estado = '1'
          AND (p_filtro IS NULL 
               OR UPPER(audi_tabla) LIKE v_filtro 
               OR UPPER(audi_operacion) LIKE v_filtro
               OR UPPER(user_nombres) LIKE v_filtro); -- Agregamos filtro por usuario

        -- 2. Obtener Registros (Usando la Vista)
        OPEN p_cursor FOR
            SELECT 
                audi_id,
                audi_tabla,
                audi_registroid,
                audi_operacion,
                audi_datoantig, -- Esto es CLOB (JSON)
                audi_datonuevo, -- Esto es CLOB (JSON)
                user_id,
                user_nombres,   -- ¡Ahora sí traemos el nombre!
                audi_fechregistro
            FROM V_AUDITORIA
            WHERE audi_estado = '1'
              AND (p_filtro IS NULL 
                   OR UPPER(audi_tabla) LIKE v_filtro 
                   OR UPPER(audi_operacion) LIKE v_filtro
                   OR UPPER(user_nombres) LIKE v_filtro)
            ORDER BY audi_id DESC
            OFFSET v_offset ROWS FETCH NEXT p_page_size ROWS ONLY;

    END SP_LISTAR_AUDITORIA;

END PKG_AUDITORIA;
/


CREATE OR REPLACE VIEW V_AUDITORIA AS
SELECT 
    a.audi_id,
    a.audi_tabla,
    a.audi_registroid,
    a.audi_operacion,
    a.audi_datoantig,
    a.audi_datonuevo,
    a.user_id,
    -- Si no hay usuario, mostramos un texto por defecto
    NVL(u.user_nombres, 'USUARIO ELIMINADO') as user_nombres,
    a.audi_estado,
    a.audi_fechregistro
FROM AUDITORIA a
LEFT JOIN USUARIO u ON a.user_id = u.user_id; -- <--- IMPORTANTE: LEFT JOIN

CREATE OR REPLACE PACKAGE BODY PKG_AUDITORIA AS

    PROCEDURE SP_LISTAR_AUDITORIA(
        p_page_number  IN NUMBER,
        p_page_size    IN NUMBER,
        p_filtro       IN VARCHAR2,
        p_total_recs   OUT NUMBER,
        p_cursor       OUT SYS_REFCURSOR
    ) IS
        v_offset NUMBER;
        v_filtro VARCHAR2(100);
    BEGIN
        v_offset := (p_page_number - 1) * p_page_size;
        v_filtro := '%' || UPPER(p_filtro) || '%';

        -- 1. CORRECCIÓN: Contamos desde la VISTA, no desde la tabla.
        -- Así aseguramos que el número coincida con lo que se va a mostrar.
        SELECT COUNT(*)
        INTO p_total_recs
        FROM V_AUDITORIA
        WHERE audi_estado = '1'
          AND (p_filtro IS NULL 
               OR UPPER(audi_tabla) LIKE v_filtro 
               OR UPPER(audi_operacion) LIKE v_filtro
               OR UPPER(user_nombres) LIKE v_filtro);

        -- 2. Seleccionamos los datos (Igual que antes)
        OPEN p_cursor FOR
            SELECT 
                audi_id,
                audi_tabla,
                audi_registroid,
                audi_operacion,
                audi_datoantig,
                audi_datonuevo,
                user_id,
                user_nombres,
                audi_fechregistro
            FROM V_AUDITORIA
            WHERE audi_estado = '1'
              AND (p_filtro IS NULL 
                   OR UPPER(audi_tabla) LIKE v_filtro 
                   OR UPPER(audi_operacion) LIKE v_filtro
                   OR UPPER(user_nombres) LIKE v_filtro)
            ORDER BY audi_id DESC
            OFFSET v_offset ROWS FETCH NEXT p_page_size ROWS ONLY;

    END SP_LISTAR_AUDITORIA;

END PKG_AUDITORIA;
/


-- 1. Aseguramos la VISTA con LEFT JOIN y manejo de Nulos
CREATE OR REPLACE VIEW V_AUDITORIA AS
SELECT 
    a.audi_id,
    a.audi_tabla,
    a.audi_registroid,
    a.audi_operacion,
    a.audi_datoantig,
    a.audi_datonuevo,
    a.user_id,
    -- Truco: Si el usuario es nulo, mostramos el ID o 'DESCONOCIDO'
    NVL(u.user_nombres, 'Usuario (' || NVL(TO_CHAR(a.user_id), '?') || ')') as user_nombres,
    a.audi_estado,
    a.audi_fechregistro
FROM AUDITORIA a
LEFT JOIN USUARIO u ON a.user_id = u.user_id;

-- 2. Recompilamos la CABECERA del paquete (Por si acaso)
CREATE OR REPLACE PACKAGE PKG_AUDITORIA AS
    PROCEDURE SP_LISTAR_AUDITORIA(
        p_page_number  IN NUMBER,
        p_page_size    IN NUMBER,
        p_filtro       IN VARCHAR2,
        p_total_recs   OUT NUMBER,
        p_cursor       OUT SYS_REFCURSOR
    );
END PKG_AUDITORIA;
/

-- 3. Recompilamos el CUERPO asegurando que COUNT y CURSOR lean de la MISMA fuente
CREATE OR REPLACE PACKAGE BODY PKG_AUDITORIA AS

    PROCEDURE SP_LISTAR_AUDITORIA(
        p_page_number  IN NUMBER,
        p_page_size    IN NUMBER,
        p_filtro       IN VARCHAR2,
        p_total_recs   OUT NUMBER,
        p_cursor       OUT SYS_REFCURSOR
    ) IS
        v_offset NUMBER;
        v_filtro VARCHAR2(100);
    BEGIN
        v_offset := (p_page_number - 1) * p_page_size;
        
        -- Manejo de filtro vacío para evitar problemas con NULLs
        IF p_filtro IS NULL OR LENGTH(TRIM(p_filtro)) = 0 THEN
            v_filtro := '%'; -- Coincide con todo
        ELSE
            v_filtro := '%' || UPPER(p_filtro) || '%';
        END IF;

        -- 1. COUNT (Desde la VISTA)
        SELECT COUNT(*)
        INTO p_total_recs
        FROM V_AUDITORIA
        WHERE audi_estado = '1'
          AND (v_filtro = '%' 
               OR UPPER(audi_tabla) LIKE v_filtro 
               OR UPPER(audi_operacion) LIKE v_filtro
               OR UPPER(user_nombres) LIKE v_filtro);

        -- 2. CURSOR (Desde la VISTA - Exactamente los mismos filtros)
        OPEN p_cursor FOR
            SELECT 
                audi_id,
                audi_tabla,
                audi_registroid,
                audi_operacion,
                audi_datoantig,
                audi_datonuevo,
                user_id,
                user_nombres,
                audi_fechregistro
            FROM V_AUDITORIA
            WHERE audi_estado = '1'
              AND (v_filtro = '%' 
                   OR UPPER(audi_tabla) LIKE v_filtro 
                   OR UPPER(audi_operacion) LIKE v_filtro
                   OR UPPER(user_nombres) LIKE v_filtro)
            ORDER BY audi_id DESC
            OFFSET v_offset ROWS FETCH NEXT p_page_size ROWS ONLY;

    END SP_LISTAR_AUDITORIA;

END PKG_AUDITORIA;
/



CREATE OR REPLACE PROCEDURE REGISTRAR_VENTA_COMPLETA (
    p_local_id        IN NUMBER,
    p_cliente_id      IN NUMBER,
    p_user_id         IN NUMBER,
    p_monto           IN NUMBER,
    p_iva             IN NUMBER,
    p_subiva          IN NUMBER,
    p_descripcion     IN VARCHAR2,
    p_detalles_json   IN CLOB,
    p_respuesta       OUT CLOB
) AS
    v_venta_id  NUMBER;
    v_caja_id   NUMBER; -- Variable para guardar el ID de la caja
BEGIN
    
    -- ---------------------------------------------------------
    -- 1. CONFIGURAR AUDITORÍA (Estrategia A)
    -- ---------------------------------------------------------
    -- Esto permite que los triggers de VENTA, DETALLE y STOCK sepan quién es el usuario
    DBMS_SESSION.SET_IDENTIFIER(TO_CHAR(p_user_id));


    -- ---------------------------------------------------------
    -- 2. CANDADO DE SEGURIDAD: VERIFICAR CAJA ABIERTA
    -- ---------------------------------------------------------
    BEGIN
        SELECT caja_id INTO v_caja_id
        FROM APERTURA_CAJA
        WHERE user_id = p_user_id 
          AND caja_estado = '1' -- Solo cajas activas
        FETCH FIRST 1 ROWS ONLY; -- Por seguridad
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            -- Si no hay caja abierta, detenemos todo y devolvemos error
            p_respuesta := JSON_OBJECT(
                'status' VALUE 'ERROR',
                'message' VALUE 'ACCESO DENEGADO: No tienes una caja abierta. Abre caja para poder vender.'
            );
            RETURN; -- <--- SALIMOS DEL PROCEDIMIENTO AQUÍ
    END;


    -- ---------------------------------------------------------
    -- 3. INSERTAR CABECERA (Ahora incluye caja_id)
    -- ---------------------------------------------------------
    INSERT INTO VENTA (
        local_id,
        client_id,
        user_id,
        caja_id, -- <--- NUEVO CAMPO VINCULADO
        venta_horafecha,
        venta_total,
        venta_iva,
        venta_subiva,
        venta_descripcion
    ) VALUES (
        p_local_id,
        p_cliente_id,
        p_user_id,
        v_caja_id, -- <--- Valor recuperado en el paso 2
        SYSDATE,
        p_monto,
        p_iva,
        p_subiva,
        p_descripcion
    )
    RETURNING venta_id INTO v_venta_id;


    -- ---------------------------------------------------------
    -- 4. PROCESAR DETALLES (Sin cambios mayores)
    -- ---------------------------------------------------------
    FOR r IN (
        SELECT *
        FROM JSON_TABLE(
            p_detalles_json,
            '$[*]' COLUMNS (
                prod_id        NUMBER PATH '$.prod_id',
                cantidad       NUMBER PATH '$.detv_cantidad',
                subtotal       NUMBER PATH '$.detv_subtotal'
            )
        )
    ) LOOP

        -- Insertar detalle
        INSERT INTO DETALLE_VENTA (
            venta_id,
            prod_id,
            detv_cantidad,
            detv_subtotal,
            detv_estado
        ) VALUES (
            v_venta_id,
            r.prod_id,
            r.cantidad,
            r.subtotal,
            1
        );

        -- Descontar stock (El trigger de auditoria de PRODUCTO se disparará aquí)
        UPDATE PRODUCTO
        SET prod_stock = prod_stock - r.cantidad
        WHERE prod_id = r.prod_id;

        -- Registrar movimiento
        INSERT INTO MOVIMIENTO_STOCK (
            movi_stock_tipomov,
            movi_stock_cantidad,
            prod_id,
            user_id,
            movi_stock_referenciadoc
        ) VALUES (
            'SALIDA_VENTA',
            r.cantidad,
            r.prod_id,
            p_user_id,
            'VENTA-' || v_venta_id
        );

    END LOOP;

    -- ---------------------------------------------------------
    -- 5. RESPUESTA EXITOSA
    -- ---------------------------------------------------------
    p_respuesta := JSON_OBJECT(
        'status' VALUE 'OK',
        'venta_id' VALUE v_venta_id,
        'message' VALUE 'Venta registrada correctamente'
    );

    COMMIT;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        p_respuesta := JSON_OBJECT(
            'status' VALUE 'ERROR',
            'message' VALUE 'Error en Base de Datos: ' || SQLERRM
        );
END;
/



CREATE OR REPLACE PROCEDURE REGISTRAR_COMPRA_COMPLETA (
    p_local_id        IN NUMBER,
    p_prove_id        IN NUMBER,
    p_user_id         IN NUMBER,
    p_monto           IN NUMBER,
    p_iva             IN NUMBER,
    p_subiva          IN NUMBER,
    p_descripcion     IN VARCHAR2,
    p_detalles_json   IN CLOB,
    p_respuesta       OUT CLOB
) AS
    v_compra_id  NUMBER;
    v_caja_id    NUMBER; -- Variable para la caja
BEGIN
    
    -- ---------------------------------------------------------
    -- 1. CONFIGURAR AUDITORÍA
    -- ---------------------------------------------------------
    DBMS_SESSION.SET_IDENTIFIER(TO_CHAR(p_user_id));

    -- ---------------------------------------------------------
    -- 2. CANDADO DE SEGURIDAD: VERIFICAR CAJA ABIERTA
    -- ---------------------------------------------------------
    BEGIN
        SELECT caja_id INTO v_caja_id
        FROM APERTURA_CAJA
        WHERE user_id = p_user_id 
          AND caja_estado = '1'
        FETCH FIRST 1 ROWS ONLY;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            p_respuesta := JSON_OBJECT(
                'status' VALUE 'ERROR',
                'message' VALUE 'ACCESO DENEGADO: No tienes una caja abierta. Abre caja para registrar compras.'
            );
            RETURN; -- Detenemos el proceso
    END;

    -- ---------------------------------------------------------
    -- 3. INSERTAR CABECERA (Incluyendo caja_id)
    -- ---------------------------------------------------------
    INSERT INTO COMPRA (
        local_id,
        prove_id,
        user_id,
        caja_id, -- <--- NUEVO CAMPO
        compra_horafecha,
        compra_montototal,
        compra_iva,
        compra_subiva,
        compra_descripcion,
        compra_estado,
        compra_estadoregistro
    ) VALUES (
        p_local_id,
        p_prove_id,
        p_user_id,
        v_caja_id, -- <--- Valor recuperado
        SYSDATE,
        p_monto,
        p_iva,
        p_subiva,
        p_descripcion,
        '1', -- Activa
        'P'  -- Pendiente de recepción (Stock no se mueve aún)
    )
    RETURNING compra_id INTO v_compra_id;

    -- ---------------------------------------------------------
    -- 4. INSERTAR DETALLES
    -- ---------------------------------------------------------
    FOR r IN (
        SELECT * FROM JSON_TABLE(p_detalles_json, '$[*]' COLUMNS (
            prod_id      NUMBER PATH '$.prod_id',
            cantidad     NUMBER PATH '$.detc_cantidad',
            precio_unit  NUMBER PATH '$.detc_preciouni',
            subtotal     NUMBER PATH '$.detc_subtotal'
        ))
    ) LOOP
        INSERT INTO DETALLE_COMPRA (
            compra_id, 
            prod_id, 
            detc_cantidad, 
            detc_preciouni, 
            detc_subtotal,
            detc_estado
        ) VALUES (
            v_compra_id, 
            r.prod_id, 
            r.cantidad, 
            r.precio_unit, 
            r.subtotal,
            '1'
        );
        -- STOCK: Se mantiene tu lógica original (No actualizar stock hasta recibir)
    END LOOP;

    -- ---------------------------------------------------------
    -- 5. RESPUESTA EXITOSA
    -- ---------------------------------------------------------
    p_respuesta := JSON_OBJECT(
        'status' VALUE 'OK', 
        'compra_id' VALUE v_compra_id, 
        'message' VALUE 'Orden de compra registrada correctamente.'
    );

    COMMIT;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        p_respuesta := JSON_OBJECT(
            'status' VALUE 'ERROR', 
            'message' VALUE 'Error BD: ' || SQLERRM
        );
END;
/
